// Code generated by protoc-gen-go.
// source: phoenix.proto
// DO NOT EDIT!

/*
Package phoenix is a generated protocol buffer package.

It is generated from these files:
	phoenix.proto

It has these top-level messages:
	Empty
	Error
	PassportInfo
	AccessToken
	ServerInfo
	AccessTokenAndServerList
	AuthInfo
*/
package phoenix

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 错误码定义
type ECODE int32

const (
	ECODE_CLIENT_INVALID  ECODE = 1
	ECODE_SERVER_INVALID  ECODE = 2
	ECODE_NETWORK_FAILURE ECODE = 3
)

var ECODE_name = map[int32]string{
	1: "CLIENT_INVALID",
	2: "SERVER_INVALID",
	3: "NETWORK_FAILURE",
}
var ECODE_value = map[string]int32{
	"CLIENT_INVALID":  1,
	"SERVER_INVALID":  2,
	"NETWORK_FAILURE": 3,
}

func (x ECODE) Enum() *ECODE {
	p := new(ECODE)
	*p = x
	return p
}
func (x ECODE) String() string {
	return proto.EnumName(ECODE_name, int32(x))
}
func (x *ECODE) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ECODE_value, data, "ECODE")
	if err != nil {
		return err
	}
	*x = ECODE(value)
	return nil
}
func (ECODE) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type CMD int32

const (
	CMD_LOGIN CMD = 100
	CMD_AUTH  CMD = 300
)

var CMD_name = map[int32]string{
	100: "LOGIN",
	300: "AUTH",
}
var CMD_value = map[string]int32{
	"LOGIN": 100,
	"AUTH":  300,
}

func (x CMD) Enum() *CMD {
	p := new(CMD)
	*p = x
	return p
}
func (x CMD) String() string {
	return proto.EnumName(CMD_name, int32(x))
}
func (x *CMD) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMD_value, data, "CMD")
	if err != nil {
		return err
	}
	*x = CMD(value)
	return nil
}
func (CMD) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type MSG int32

const (
	MSG_ERROR                        MSG = 50
	MSG_SERVER_LIST_AND_ACCESS_TOKEN MSG = 200
	MSG_LOGIN_SUCCESS                MSG = 400
)

var MSG_name = map[int32]string{
	50:  "ERROR",
	200: "SERVER_LIST_AND_ACCESS_TOKEN",
	400: "LOGIN_SUCCESS",
}
var MSG_value = map[string]int32{
	"ERROR": 50,
	"SERVER_LIST_AND_ACCESS_TOKEN": 200,
	"LOGIN_SUCCESS":                400,
}

func (x MSG) Enum() *MSG {
	p := new(MSG)
	*p = x
	return p
}
func (x MSG) String() string {
	return proto.EnumName(MSG_name, int32(x))
}
func (x *MSG) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MSG_value, data, "MSG")
	if err != nil {
		return err
	}
	*x = MSG(value)
	return nil
}
func (MSG) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// 空消息
type Empty struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// 错误消息包
type Error struct {
	Code             *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Args             []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Error) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Error) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type PassportInfo struct {
	Channel          *string `protobuf:"bytes,1,req,name=channel" json:"channel,omitempty"`
	Imei             *string `protobuf:"bytes,2,req,name=imei" json:"imei,omitempty"`
	Way              *uint32 `protobuf:"varint,3,req,name=way" json:"way,omitempty"`
	Key              *string `protobuf:"bytes,4,req,name=key" json:"key,omitempty"`
	UserId           *string `protobuf:"bytes,5,opt,name=user_id" json:"user_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PassportInfo) Reset()                    { *m = PassportInfo{} }
func (m *PassportInfo) String() string            { return proto.CompactTextString(m) }
func (*PassportInfo) ProtoMessage()               {}
func (*PassportInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PassportInfo) GetChannel() string {
	if m != nil && m.Channel != nil {
		return *m.Channel
	}
	return ""
}

func (m *PassportInfo) GetImei() string {
	if m != nil && m.Imei != nil {
		return *m.Imei
	}
	return ""
}

func (m *PassportInfo) GetWay() uint32 {
	if m != nil && m.Way != nil {
		return *m.Way
	}
	return 0
}

func (m *PassportInfo) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *PassportInfo) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

type AccessToken struct {
	Uid              *uint32 `protobuf:"varint,1,req,name=uid" json:"uid,omitempty"`
	Secret           []byte  `protobuf:"bytes,2,req,name=secret" json:"secret,omitempty"`
	Newbie           *bool   `protobuf:"varint,3,req,name=newbie" json:"newbie,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AccessToken) Reset()                    { *m = AccessToken{} }
func (m *AccessToken) String() string            { return proto.CompactTextString(m) }
func (*AccessToken) ProtoMessage()               {}
func (*AccessToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AccessToken) GetUid() uint32 {
	if m != nil && m.Uid != nil {
		return *m.Uid
	}
	return 0
}

func (m *AccessToken) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *AccessToken) GetNewbie() bool {
	if m != nil && m.Newbie != nil {
		return *m.Newbie
	}
	return false
}

type ServerInfo struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Addr             *string `protobuf:"bytes,2,req,name=addr" json:"addr,omitempty"`
	Port             *int32  `protobuf:"varint,3,req,name=port" json:"port,omitempty"`
	ServerId         *int32  `protobuf:"varint,4,req,name=server_id" json:"server_id,omitempty"`
	Opened           *bool   `protobuf:"varint,5,req,name=opened" json:"opened,omitempty"`
	Recommended      *bool   `protobuf:"varint,6,req,name=recommended" json:"recommended,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ServerInfo) Reset()                    { *m = ServerInfo{} }
func (m *ServerInfo) String() string            { return proto.CompactTextString(m) }
func (*ServerInfo) ProtoMessage()               {}
func (*ServerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ServerInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ServerInfo) GetAddr() string {
	if m != nil && m.Addr != nil {
		return *m.Addr
	}
	return ""
}

func (m *ServerInfo) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *ServerInfo) GetServerId() int32 {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return 0
}

func (m *ServerInfo) GetOpened() bool {
	if m != nil && m.Opened != nil {
		return *m.Opened
	}
	return false
}

func (m *ServerInfo) GetRecommended() bool {
	if m != nil && m.Recommended != nil {
		return *m.Recommended
	}
	return false
}

type AccessTokenAndServerList struct {
	Token            *AccessToken  `protobuf:"bytes,1,req,name=token" json:"token,omitempty"`
	Servers          []*ServerInfo `protobuf:"bytes,2,rep,name=servers" json:"servers,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *AccessTokenAndServerList) Reset()                    { *m = AccessTokenAndServerList{} }
func (m *AccessTokenAndServerList) String() string            { return proto.CompactTextString(m) }
func (*AccessTokenAndServerList) ProtoMessage()               {}
func (*AccessTokenAndServerList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AccessTokenAndServerList) GetToken() *AccessToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *AccessTokenAndServerList) GetServers() []*ServerInfo {
	if m != nil {
		return m.Servers
	}
	return nil
}

type AuthInfo struct {
	Uid              *uint32 `protobuf:"varint,1,req,name=uid" json:"uid,omitempty"`
	Secret           []byte  `protobuf:"bytes,2,req,name=secret" json:"secret,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AuthInfo) Reset()                    { *m = AuthInfo{} }
func (m *AuthInfo) String() string            { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()               {}
func (*AuthInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *AuthInfo) GetUid() uint32 {
	if m != nil && m.Uid != nil {
		return *m.Uid
	}
	return 0
}

func (m *AuthInfo) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "phoenix.Empty")
	proto.RegisterType((*Error)(nil), "phoenix.Error")
	proto.RegisterType((*PassportInfo)(nil), "phoenix.PassportInfo")
	proto.RegisterType((*AccessToken)(nil), "phoenix.AccessToken")
	proto.RegisterType((*ServerInfo)(nil), "phoenix.ServerInfo")
	proto.RegisterType((*AccessTokenAndServerList)(nil), "phoenix.AccessTokenAndServerList")
	proto.RegisterType((*AuthInfo)(nil), "phoenix.AuthInfo")
	proto.RegisterEnum("phoenix.ECODE", ECODE_name, ECODE_value)
	proto.RegisterEnum("phoenix.CMD", CMD_name, CMD_value)
	proto.RegisterEnum("phoenix.MSG", MSG_name, MSG_value)
}

func init() { proto.RegisterFile("phoenix.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x90, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x15, 0xff, 0x49, 0xe2, 0x71, 0xfe, 0x98, 0x0d, 0x07, 0x4b, 0x70, 0x08, 0x2e, 0x12,
	0x51, 0x0e, 0x3d, 0xe4, 0xc8, 0xcd, 0x24, 0x4b, 0x6a, 0xd5, 0x75, 0x90, 0xed, 0x14, 0x6e, 0x96,
	0xb1, 0x07, 0x62, 0x95, 0xec, 0x5a, 0x6b, 0x87, 0x92, 0xb7, 0xe0, 0x41, 0x78, 0x10, 0x1e, 0x0b,
	0xed, 0x26, 0xb4, 0x3d, 0xf5, 0x38, 0x33, 0xdf, 0x7c, 0xdf, 0x6f, 0x06, 0x86, 0xf5, 0x8e, 0x23,
	0xab, 0x7e, 0x5d, 0xd6, 0x82, 0xb7, 0x9c, 0xf4, 0xce, 0xa5, 0xd7, 0x03, 0x93, 0xee, 0xeb, 0xf6,
	0xe8, 0x5d, 0x80, 0x49, 0x85, 0xe0, 0x82, 0x0c, 0xc0, 0x28, 0x78, 0x89, 0x6e, 0x67, 0xaa, 0xcd,
	0x86, 0xb2, 0xca, 0xc5, 0xf7, 0xc6, 0xd5, 0xa6, 0xfa, 0xcc, 0xf2, 0xbe, 0xc0, 0xe0, 0x53, 0xde,
	0x34, 0x35, 0x17, 0x6d, 0xc0, 0xbe, 0x71, 0x32, 0x86, 0x5e, 0xb1, 0xcb, 0x19, 0xc3, 0x1f, 0x4a,
	0x6e, 0x49, 0x79, 0xb5, 0xc7, 0xca, 0xd5, 0x54, 0x65, 0x83, 0x7e, 0x9f, 0x1f, 0x5d, 0x5d, 0x39,
	0xd9, 0xa0, 0xdf, 0xe1, 0xd1, 0x35, 0xd4, 0x64, 0x0c, 0xbd, 0x43, 0x83, 0x22, 0xab, 0x4a, 0xd7,
	0x9c, 0x76, 0x66, 0x96, 0xf7, 0x1e, 0x6c, 0xbf, 0x28, 0xb0, 0x69, 0x52, 0x7e, 0x87, 0x4c, 0x8a,
	0x0f, 0x55, 0x79, 0x66, 0x18, 0x41, 0xb7, 0xc1, 0x42, 0x60, 0xab, 0x6c, 0x07, 0xb2, 0x66, 0x78,
	0xff, 0xb5, 0x42, 0xe5, 0xdc, 0xf7, 0x18, 0x40, 0x82, 0xe2, 0x27, 0x0a, 0xc5, 0x34, 0x00, 0x83,
	0xe5, 0x7b, 0x7c, 0x04, 0xca, 0xcb, 0x52, 0x9c, 0x81, 0x06, 0x60, 0x48, 0x76, 0xb5, 0x67, 0x92,
	0x17, 0x60, 0x35, 0x6a, 0x4f, 0x62, 0x18, 0xaa, 0x35, 0x82, 0x2e, 0xaf, 0x91, 0xa1, 0xc4, 0xd2,
	0x66, 0x7d, 0x32, 0x01, 0x5b, 0x60, 0xc1, 0xf7, 0x7b, 0x64, 0x25, 0x96, 0x6e, 0x57, 0xe5, 0x21,
	0xb8, 0x4f, 0x58, 0x7d, 0x56, 0x9e, 0xd2, 0xc3, 0xaa, 0x69, 0xc9, 0x05, 0x98, 0xad, 0xec, 0xaa,
	0x78, 0x7b, 0xf1, 0xf2, 0xf2, 0xff, 0xdf, 0x9f, 0x5e, 0xf7, 0x16, 0x7a, 0xa7, 0xe0, 0xd3, 0x5f,
	0xed, 0xc5, 0xe4, 0x41, 0xf6, 0x78, 0x88, 0xf7, 0x0e, 0xfa, 0xfe, 0xa1, 0xdd, 0xa9, 0xa3, 0x9e,
	0xfb, 0xc7, 0x7c, 0x05, 0x26, 0x5d, 0x6e, 0x56, 0x94, 0x10, 0x18, 0x2d, 0xc3, 0x80, 0x46, 0x69,
	0x16, 0x44, 0xb7, 0x7e, 0x18, 0xac, 0x9c, 0x8e, 0xec, 0x25, 0x34, 0xbe, 0xa5, 0xf1, 0x43, 0x4f,
	0x23, 0x13, 0x18, 0x47, 0x34, 0xfd, 0xbc, 0x89, 0xaf, 0xb3, 0x8f, 0x7e, 0x10, 0x6e, 0x63, 0xea,
	0xe8, 0xf3, 0x57, 0xa0, 0x2f, 0x6f, 0x56, 0xc4, 0x02, 0x33, 0xdc, 0xac, 0x83, 0xc8, 0x29, 0x89,
	0x05, 0x86, 0xbf, 0x4d, 0xaf, 0x9c, 0x3f, 0xda, 0x7c, 0x0d, 0xfa, 0x4d, 0xb2, 0x96, 0x43, 0x1a,
	0xc7, 0x9b, 0xd8, 0x59, 0x90, 0x37, 0xf0, 0xfa, 0xec, 0x1b, 0x06, 0x49, 0x9a, 0xf9, 0xd1, 0x2a,
	0xf3, 0x97, 0x4b, 0x9a, 0x24, 0x59, 0xba, 0xb9, 0xa6, 0x91, 0xf3, 0x57, 0x46, 0x0f, 0x95, 0x55,
	0x96, 0x6c, 0xd5, 0xc4, 0xf9, 0xad, 0x7f, 0xd0, 0xae, 0xf4, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x87, 0x81, 0x3d, 0x88, 0x8c, 0x02, 0x00, 0x00,
}
